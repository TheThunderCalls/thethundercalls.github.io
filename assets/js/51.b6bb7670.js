(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{332:function(t,a,v){"use strict";v.r(a);var _=v(10),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"lambda表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式"}},[t._v("#")]),t._v(" Lambda表达式")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("Lambda 表达式是 JDK8 中的一个语法糖。它可以对某些匿名内部类的写法进行简化。是函数式编程思想的一个重要体现。让我们不用关注是什么对象，而是更关注对数据进行了什么操作")]),t._v(" "),a("h2",{attrs:{id:"入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入门"}},[t._v("#")]),t._v(" 入门")]),t._v(" "),a("h3",{attrs:{id:"基本格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本格式"}},[t._v("#")]),t._v(" 基本格式")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("参数列表"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("代码块"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"省略规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#省略规则"}},[t._v("#")]),t._v(" 省略规则")]),t._v(" "),a("ul",[a("li",[t._v("参数类型可以省略")]),t._v(" "),a("li",[t._v("方法体中只有一句代码时， {}、return 和 ; 都可以省略")]),t._v(" "),a("li",[t._v("方法只有一个参数时， () 可以省略")])]),t._v(" "),a("h3",{attrs:{id:"示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),a("h2",{attrs:{id:"函数式接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数式接口"}},[t._v("#")]),t._v(" 函数式接口")]),t._v(" "),a("p",[t._v("只有一个抽象方法的接口我们称之为函数式接口")]),t._v(" "),a("p",[t._v("JDK 的函数式接口都加上了 @FunctionalInterface 注解进行标识，但是无论是否加上该注解，只要接口中只有一个抽象方法，都是函数式接口")]),t._v(" "),a("h3",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("p",[t._v("是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口")]),t._v(" "),a("p",[t._v("在一个接口上使用 @FunctionalInterface 注解，可以检查它是否是一个函数式接口")]),t._v(" "),a("p",[t._v("只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示")]),t._v(" "),a("h3",{attrs:{id:"内置核心函数式接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置核心函数式接口"}},[t._v("#")]),t._v(" 内置核心函数式接口")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("函数式接口")]),t._v(" "),a("th",[t._v("参数类型")]),t._v(" "),a("th",[t._v("返回值类型")]),t._v(" "),a("th",[t._v("用途")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Consumer"),a("T")],1),t._v(" "),a("td",[t._v("T")]),t._v(" "),a("td",[t._v("void")]),t._v(" "),a("td",[t._v("消费型接口，对类型为 T 的对象应用操作")])]),t._v(" "),a("tr",[a("td",[t._v("Supplier"),a("T")],1),t._v(" "),a("td",[t._v("无")]),t._v(" "),a("td",[t._v("T")]),t._v(" "),a("td",[t._v("供给型接口，返回类型为 T 的对象")])]),t._v(" "),a("tr",[a("td",[t._v("Function<T, R>")]),t._v(" "),a("td",[t._v("T")]),t._v(" "),a("td",[t._v("R")]),t._v(" "),a("td",[t._v("函数型接口，对类型为 T 的对象应用操作，并返回 R 类型的对象的结果")])]),t._v(" "),a("tr",[a("td",[t._v("Predicate"),a("T")],1),t._v(" "),a("td",[t._v("T")]),t._v(" "),a("td",[t._v("boolean")]),t._v(" "),a("td",[t._v("断定型接口，确定类型为 T 的对象是否满足某约束，返回 boolean 值")])])])]),t._v(" "),a("h3",{attrs:{id:"示例-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")])])}),[],!1,null,null,null);a.default=s.exports}}]);